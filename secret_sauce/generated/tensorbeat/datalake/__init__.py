# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: tensorbeat/datalake.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import Dict, List, Optional

import betterproto
from betterproto.grpc.grpclib_server import ServiceBase
import grpclib


class Filter(betterproto.Enum):
    ANY = 0
    ALL = 1
    NONE = 2


@dataclass(eq=False, repr=False)
class GetSongsByTagsRequest(betterproto.Message):
    # Pass in map of tags to be matched on returned songs EX: { "genre": "rock",
    # "spectrogram_id": "*", } The tags will be combined using the filter: - ANY
    # means songs matching any of the tags will be returned. - ALL   means songs
    # matching all of the tags will be returned. - NONE  means songs that dont
    # match any of the tags will be returned. Using an * for the value will
    # return any song with that tag set. Using a specific value for the tag will
    # return only songs with that exact combination of Key/Value
    tags: Dict[str, str] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    filter: "Filter" = betterproto.enum_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class GetSongsByTagsResponse(betterproto.Message):
    songs: List["_common__.File"] = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class AddSongsRequest(betterproto.Message):
    songs: List["_common__.AddFile"] = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class AddSongsResponse(betterproto.Message):
    successful: bool = betterproto.bool_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class AddTagsRequest(betterproto.Message):
    id: str = betterproto.string_field(1)
    tags: Dict[str, str] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class AddTagsResponse(betterproto.Message):
    successful: bool = betterproto.bool_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class RemoveTagsRequest(betterproto.Message):
    id: str = betterproto.string_field(1)
    tags: Dict[str, str] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class RemoveTagsResponse(betterproto.Message):
    successful: bool = betterproto.bool_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class GetAllSongsRequest(betterproto.Message):
    pass

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class GetAllSongsResponse(betterproto.Message):
    songs: List["_common__.File"] = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class GetSongsByIDsRequest(betterproto.Message):
    ids: List[str] = betterproto.string_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class GetSongsByIDsResponse(betterproto.Message):
    songs: List["_common__.File"] = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


class DatalakeServiceStub(betterproto.ServiceStub):
    async def get_all_songs(self) -> "GetAllSongsResponse":

        request = GetAllSongsRequest()

        return await self._unary_unary(
            "/tensorbeat.datalake.DatalakeService/GetAllSongs",
            request,
            GetAllSongsResponse,
        )

    async def get_songs_by_i_ds(
        self, *, ids: Optional[List[str]] = None
    ) -> "GetSongsByIDsResponse":
        ids = ids or []

        request = GetSongsByIDsRequest()
        request.ids = ids

        return await self._unary_unary(
            "/tensorbeat.datalake.DatalakeService/GetSongsByIDs",
            request,
            GetSongsByIDsResponse,
        )

    async def get_songs_by_tags(
        self, *, tags: Dict[str, str] = None, filter: "Filter" = None
    ) -> "GetSongsByTagsResponse":

        request = GetSongsByTagsRequest()
        request.tags = tags
        request.filter = filter

        return await self._unary_unary(
            "/tensorbeat.datalake.DatalakeService/GetSongsByTags",
            request,
            GetSongsByTagsResponse,
        )

    async def add_songs(
        self, *, songs: Optional[List["_common__.AddFile"]] = None
    ) -> "AddSongsResponse":
        songs = songs or []

        request = AddSongsRequest()
        if songs is not None:
            request.songs = songs

        return await self._unary_unary(
            "/tensorbeat.datalake.DatalakeService/AddSongs", request, AddSongsResponse
        )

    async def add_tags(
        self, *, id: str = "", tags: Dict[str, str] = None
    ) -> "AddTagsResponse":

        request = AddTagsRequest()
        request.id = id
        request.tags = tags

        return await self._unary_unary(
            "/tensorbeat.datalake.DatalakeService/AddTags", request, AddTagsResponse
        )

    async def remove_tags(
        self, *, id: str = "", tags: Dict[str, str] = None
    ) -> "RemoveTagsResponse":

        request = RemoveTagsRequest()
        request.id = id
        request.tags = tags

        return await self._unary_unary(
            "/tensorbeat.datalake.DatalakeService/RemoveTags",
            request,
            RemoveTagsResponse,
        )


class DatalakeServiceBase(ServiceBase):
    async def get_all_songs(self) -> "GetAllSongsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_songs_by_i_ds(
        self, ids: Optional[List[str]]
    ) -> "GetSongsByIDsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_songs_by_tags(
        self, tags: Dict[str, str], filter: "Filter"
    ) -> "GetSongsByTagsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def add_songs(
        self, songs: Optional[List["_common__.AddFile"]]
    ) -> "AddSongsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def add_tags(self, id: str, tags: Dict[str, str]) -> "AddTagsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def remove_tags(self, id: str, tags: Dict[str, str]) -> "RemoveTagsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_get_all_songs(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.get_all_songs(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_get_songs_by_i_ds(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "ids": request.ids,
        }

        response = await self.get_songs_by_i_ds(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_get_songs_by_tags(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "tags": request.tags,
            "filter": request.filter,
        }

        response = await self.get_songs_by_tags(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_add_songs(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "songs": request.songs,
        }

        response = await self.add_songs(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_add_tags(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "id": request.id,
            "tags": request.tags,
        }

        response = await self.add_tags(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_remove_tags(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "id": request.id,
            "tags": request.tags,
        }

        response = await self.remove_tags(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/tensorbeat.datalake.DatalakeService/GetAllSongs": grpclib.const.Handler(
                self.__rpc_get_all_songs,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetAllSongsRequest,
                GetAllSongsResponse,
            ),
            "/tensorbeat.datalake.DatalakeService/GetSongsByIDs": grpclib.const.Handler(
                self.__rpc_get_songs_by_i_ds,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetSongsByIDsRequest,
                GetSongsByIDsResponse,
            ),
            "/tensorbeat.datalake.DatalakeService/GetSongsByTags": grpclib.const.Handler(
                self.__rpc_get_songs_by_tags,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetSongsByTagsRequest,
                GetSongsByTagsResponse,
            ),
            "/tensorbeat.datalake.DatalakeService/AddSongs": grpclib.const.Handler(
                self.__rpc_add_songs,
                grpclib.const.Cardinality.UNARY_UNARY,
                AddSongsRequest,
                AddSongsResponse,
            ),
            "/tensorbeat.datalake.DatalakeService/AddTags": grpclib.const.Handler(
                self.__rpc_add_tags,
                grpclib.const.Cardinality.UNARY_UNARY,
                AddTagsRequest,
                AddTagsResponse,
            ),
            "/tensorbeat.datalake.DatalakeService/RemoveTags": grpclib.const.Handler(
                self.__rpc_remove_tags,
                grpclib.const.Cardinality.UNARY_UNARY,
                RemoveTagsRequest,
                RemoveTagsResponse,
            ),
        }


from .. import common as _common__
